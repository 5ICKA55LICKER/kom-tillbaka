{"version":3,"sources":["../node_modules/@sanity/block-content-to-hyperscript/internals.js","../../src/getImageUrl.js","../../src/mergeSerializers.js","../../src/BlockContent.js","../../src/internals.js","../../src/serializers.js","../node_modules/@sanity/block-content-to-hyperscript/node_modules/@sanity/generate-help-url/index.js","../../src/blocksToNodes.js","../../src/buildMarksTree.js","../../src/nestLists.js","../../src/generateKeys.js","../../../src/targets/dom.js","pages/about.component.jsx"],"names":["module","exports","require","generateHelpUrl","urlBuilder","objectAssign","enc","materializeError","props","node","options","projectId","dataset","asset","Error","query","keys","Object","params","key","getQueryString","defaultSerializers","userSerializers","type","acc","isDefined","React","PropTypes","internals","serializers","serializeSpan","renderProps","getImageUrl","blocksToNodes","mergeSerializers","renderNode","SanityBlockContent","customSerializers","blockProps","assign","blocks","className","renderContainerOnSingleChild","imageOptions","shape","types","marks","list","listItem","block","span","func","oneOfType","arrayOf","_type","isRequired","getSerializers","serializeOptions","serializerOpts","useDashedStyles","h","tag","style","test","image","img","src","strong","RawMarkSerializer","em","code","underline","textDecoration","link","href","children","isInline","blockType","serializer","mark","markType","console","hardBreak","container","markFallback","text","empty","serializedNode","slug","buildMarksTree","nestLists","generateKeys","optionProps","defaults","isListItem","properties","rawBlocks","Array","keyedBlocks","value","opts","level","serializeList","tree","index","serializeListItem","i","siblings","findListItemIndex","isSpan","serializeNode","serializeBlock","Boolean","nodes","containerProps","defaultMarks","sortMarksByOccurences","spans","markOccurences","occurences","siblingIndex","sibling","sortByOccurence","sortMarks","markA","markB","aOccurences","bOccurences","aDefaultPos","bDefaultPos","markDefs","sortedMarks","rootNode","nodeStack","marksNeeded","pos","currentNode","findLastParentNode","_key","def","markKey","lines","line","lastNode","isListBlock","blockMatchesList","listFromBlock","lastChild","findListMatching","matching","filterOnType","mode","currentList","newList","lastListItem","newLastChild","match","checksum","str","hash","strlen","item","JSON","nestMarks","Container","styled","div","DescContainer","Desc","PortableText","Press","p","PressLinkContainer","PressLink","a","About","about","useContext","AboutContext","pressMessage","press","map","id","name"],"mappings":"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","file":"static/js/3.16cf6b8d.chunk.js","sourcesContent":["module.exports = require('./lib/internals')\n","const generateHelpUrl = require('@sanity/generate-help-url')\nconst urlBuilder = require('@sanity/image-url')\nconst objectAssign = require('object-assign')\n\nconst enc = encodeURIComponent\nconst materializeError = `You must either:\n  - Pass \\`projectId\\` and \\`dataset\\` to the block renderer\n  - Materialize images to include the \\`url\\` field.\n\nFor more information, see ${generateHelpUrl('block-content-image-materializing')}`\n\nconst getQueryString = options => {\n  const query = options.imageOptions\n  const keys = Object.keys(query)\n  if (!keys.length) {\n    return ''\n  }\n\n  const params = keys.map(key => `${enc(key)}=${enc(query[key])}`)\n  return `?${params.join('&')}`\n}\n\nconst buildUrl = props => {\n  const {node, options} = props\n  const {projectId, dataset} = options\n  const asset = node.asset\n\n  if (!asset) {\n    throw new Error('Image does not have required `asset` property')\n  }\n\n  if (asset.url) {\n    return asset.url + getQueryString(options)\n  }\n\n  if (!projectId || !dataset) {\n    throw new Error(materializeError)\n  }\n\n  const ref = asset._ref\n  if (!ref) {\n    throw new Error('Invalid image reference in block, no `_ref` found on `asset`')\n  }\n\n  return urlBuilder(objectAssign({projectId, dataset}, options.imageOptions || {}))\n    .image(node)\n    .toString()\n}\n\nmodule.exports = buildUrl\n","const objectAssign = require('object-assign')\nconst isDefined = val => typeof val !== 'undefined'\n\n// Recursively merge/replace default serializers with user-specified serializers\nmodule.exports = function mergeSerializers(defaultSerializers, userSerializers) {\n  return Object.keys(defaultSerializers).reduce((acc, key) => {\n    const type = typeof defaultSerializers[key]\n    if (type === 'function') {\n      acc[key] = isDefined(userSerializers[key]) ? userSerializers[key] : defaultSerializers[key]\n    } else if (type === 'object') {\n      acc[key] = objectAssign({}, defaultSerializers[key], userSerializers[key])\n    } else {\n      acc[key] =\n        typeof userSerializers[key] === 'undefined' ? defaultSerializers[key] : userSerializers[key]\n    }\n    return acc\n  }, {})\n}\n","const React = require('react')\nconst PropTypes = require('prop-types')\nconst internals = require('@sanity/block-content-to-hyperscript/internals')\nconst {serializers, serializeSpan, renderProps} = require('./targets/dom')\n\nconst {getImageUrl, blocksToNodes, mergeSerializers} = internals\nconst renderNode = React.createElement\n\nconst SanityBlockContent = props => {\n  const customSerializers = mergeSerializers(\n    SanityBlockContent.defaultSerializers,\n    props.serializers\n  )\n\n  const blockProps = Object.assign({}, renderProps, props, {\n    serializers: customSerializers,\n    blocks: props.blocks || []\n  })\n\n  return blocksToNodes(renderNode, blockProps, serializers, serializeSpan)\n}\n\n// Expose default serializers to the user\nSanityBlockContent.defaultSerializers = serializers\n\n// Expose logic for building image URLs from an image reference/node\nSanityBlockContent.getImageUrl = getImageUrl\n\nSanityBlockContent.propTypes = {\n  className: PropTypes.string,\n  renderContainerOnSingleChild: PropTypes.bool,\n\n  // When rendering images, we need project id and dataset, unless images are materialized\n  projectId: PropTypes.string,\n  dataset: PropTypes.string,\n  imageOptions: PropTypes.object,\n\n  serializers: PropTypes.shape({\n    // Common overrides\n    types: PropTypes.object,\n    marks: PropTypes.object,\n\n    // Less common overrides\n    list: PropTypes.func,\n    listItem: PropTypes.func,\n\n    // Low-level serializers\n    block: PropTypes.func,\n    span: PropTypes.func\n  }),\n\n  blocks: PropTypes.oneOfType([\n    PropTypes.arrayOf(\n      PropTypes.shape({\n        _type: PropTypes.string.isRequired\n      })\n    ),\n    PropTypes.shape({\n      _type: PropTypes.string.isRequired\n    })\n  ]).isRequired\n}\n\nSanityBlockContent.defaultProps = {\n  renderContainerOnSingleChild: false,\n  serializers: {},\n  imageOptions: {}\n}\n\nmodule.exports = SanityBlockContent\n","const getSerializers = require('./serializers')\nconst blocksToNodes = require('./blocksToNodes')\nconst getImageUrl = require('./getImageUrl')\nconst mergeSerializers = require('./mergeSerializers')\n\nmodule.exports = {\n  blocksToNodes: (renderNode, props, defaultSerializers, serializeSpan) => {\n    if (defaultSerializers) {\n      return blocksToNodes(renderNode, props, defaultSerializers, serializeSpan)\n    }\n\n    // Backwards-compatibility\n    const serializers = getSerializers(renderNode)\n    return blocksToNodes(\n      renderNode,\n      props,\n      serializers.defaultSerializers,\n      serializers.serializeSpan\n    )\n  },\n  getSerializers,\n  getImageUrl,\n  mergeSerializers\n}\n","const objectAssign = require('object-assign')\nconst getImageUrl = require('./getImageUrl')\n\nmodule.exports = (h, serializerOpts) => {\n  const serializeOptions = serializerOpts || {useDashedStyles: false}\n\n  // Low-level block serializer\n  function BlockSerializer(props) {\n    const {node, serializers, options, isInline, children} = props\n    const blockType = node._type\n    const serializer = serializers.types[blockType]\n    if (!serializer) {\n      throw new Error(\n        `Unknown block type \"${blockType}\", please specify a serializer for it in the \\`serializers.types\\` prop`\n      )\n    }\n\n    return h(serializer, {node, options, isInline}, children)\n  }\n\n  // Low-level span serializer\n  function SpanSerializer(props) {\n    const {mark, children} = props.node\n    const isPlain = typeof mark === 'string'\n    const markType = isPlain ? mark : mark._type\n    const serializer = props.serializers.marks[markType]\n    if (!serializer) {\n      // @todo Revert back to throwing errors?\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Unknown mark type \"${markType}\", please specify a serializer for it in the \\`serializers.marks\\` prop`\n      )\n      return h(props.serializers.markFallback, null, children)\n    }\n\n    return h(serializer, props.node, children)\n  }\n\n  // Low-level list serializer\n  function ListSerializer(props) {\n    const tag = props.type === 'bullet' ? 'ul' : 'ol'\n    return h(tag, null, props.children)\n  }\n\n  // Low-level list item serializer\n  function ListItemSerializer(props) {\n    const children =\n      !props.node.style || props.node.style === 'normal'\n        ? // Don't wrap plain text in paragraphs inside of a list item\n          props.children\n        : // But wrap any other style in whatever the block serializer says to use\n          h(props.serializers.types.block, props, props.children)\n\n    return h('li', null, children)\n  }\n\n  // Renderer of an actual block of type `block`. Confusing, we know.\n  function BlockTypeSerializer(props) {\n    const style = props.node.style || 'normal'\n\n    if (/^h\\d/.test(style)) {\n      return h(style, null, props.children)\n    }\n\n    return style === 'blockquote'\n      ? h('blockquote', null, props.children)\n      : h('p', null, props.children)\n  }\n\n  // Serializers for things that can be directly attributed to a tag without any props\n  // We use partial application to do this, passing the tag name as the first argument\n  function RawMarkSerializer(tag, props) {\n    return h(tag, null, props.children)\n  }\n\n  function UnderlineSerializer(props) {\n    const style = serializeOptions.useDashedStyles\n      ? {'text-decoration': 'underline'}\n      : {textDecoration: 'underline'}\n\n    return h('span', {style}, props.children)\n  }\n\n  function StrikeThroughSerializer(props) {\n    return h('del', null, props.children)\n  }\n\n  function LinkSerializer(props) {\n    return h('a', {href: props.mark.href}, props.children)\n  }\n\n  function ImageSerializer(props) {\n    if (!props.node.asset) {\n      return null\n    }\n\n    const img = h('img', {src: getImageUrl(props)})\n    return props.isInline ? img : h('figure', null, img)\n  }\n\n  // Serializer that recursively calls itself, producing a hyperscript tree of spans\n  function serializeSpan(span, serializers, index, options) {\n    if (span === '\\n' && serializers.hardBreak) {\n      return h(serializers.hardBreak, {key: `hb-${index}`})\n    }\n\n    if (typeof span === 'string') {\n      return serializers.text ? h(serializers.text, {key: `text-${index}`}, span) : span\n    }\n\n    let children\n    if (span.children) {\n      children = {\n        children: span.children.map((child, i) =>\n          options.serializeNode(child, i, span.children, true)\n        )\n      }\n    }\n\n    const serializedNode = objectAssign({}, span, children)\n\n    return h(serializers.span, {\n      key: span._key || `span-${index}`,\n      node: serializedNode,\n      serializers\n    })\n  }\n\n  const HardBreakSerializer = () => h('br')\n  const defaultMarkSerializers = {\n    strong: RawMarkSerializer.bind(null, 'strong'),\n    em: RawMarkSerializer.bind(null, 'em'),\n    code: RawMarkSerializer.bind(null, 'code'),\n    underline: UnderlineSerializer,\n    'strike-through': StrikeThroughSerializer,\n    link: LinkSerializer\n  }\n\n  const defaultSerializers = {\n    // Common overrides\n    types: {\n      block: BlockTypeSerializer,\n      image: ImageSerializer\n    },\n    marks: defaultMarkSerializers,\n\n    // Less common overrides\n    list: ListSerializer,\n    listItem: ListItemSerializer,\n\n    block: BlockSerializer,\n    span: SpanSerializer,\n    hardBreak: HardBreakSerializer,\n\n    // Container element\n    container: 'div',\n\n    // When we can't resolve the mark properly, use this renderer as the container\n    markFallback: 'span',\n\n    // Allow overriding text renderer, but leave undefined to just use plain strings by default\n    text: undefined,\n\n    // Empty nodes (React uses null, hyperscript with empty strings)\n    empty: ''\n  }\n\n  return {\n    defaultSerializers,\n    serializeSpan\n  }\n}\n","var baseUrl = 'https://docs.sanity.io/help/'\n\nmodule.exports = function generateHelpUrl(slug) {\n  return baseUrl + slug\n}\n","const objectAssign = require('object-assign')\nconst buildMarksTree = require('./buildMarksTree')\nconst nestLists = require('./nestLists')\nconst generateKeys = require('./generateKeys')\nconst mergeSerializers = require('./mergeSerializers')\n\n// Properties to extract from props and pass to serializers as options\nconst optionProps = ['projectId', 'dataset', 'imageOptions']\nconst isDefined = val => typeof val !== 'undefined'\nconst defaults = {imageOptions: {}}\n\nfunction blocksToNodes(h, properties, defaultSerializers, serializeSpan) {\n  const props = objectAssign({}, defaults, properties)\n  const rawBlocks = Array.isArray(props.blocks) ? props.blocks : [props.blocks]\n  const keyedBlocks = generateKeys(rawBlocks)\n  const blocks = nestLists(keyedBlocks, props.listNestMode)\n  const serializers = mergeSerializers(defaultSerializers, props.serializers || {})\n\n  const options = optionProps.reduce((opts, key) => {\n    const value = props[key]\n    if (isDefined(value)) {\n      opts[key] = value\n    }\n    return opts\n  }, {})\n\n  function serializeNode(node, index, siblings, isInline) {\n    if (isList(node)) {\n      return serializeList(node)\n    }\n\n    if (isListItem(node)) {\n      return serializeListItem(node, findListItemIndex(node, siblings))\n    }\n\n    if (isSpan(node)) {\n      return serializeSpan(node, serializers, index, {serializeNode})\n    }\n\n    return serializeBlock(node, index, isInline)\n  }\n\n  function findListItemIndex(node, siblings) {\n    let index = 0\n    for (let i = 0; i < siblings.length; i++) {\n      if (siblings[i] === node) {\n        return index\n      }\n\n      if (!isListItem(siblings[i])) {\n        continue\n      }\n\n      index++\n    }\n\n    return index\n  }\n\n  function serializeBlock(block, index, isInline) {\n    const tree = buildMarksTree(block)\n    const children = tree.map((node, i, siblings) => serializeNode(node, i, siblings, true))\n    const blockProps = {\n      key: block._key || `block-${index}`,\n      node: block,\n      isInline,\n      serializers,\n      options\n    }\n\n    return h(serializers.block, blockProps, children)\n  }\n\n  function serializeListItem(block, index) {\n    const key = block._key\n    const tree = buildMarksTree(block)\n    const children = tree.map(serializeNode)\n    return h(serializers.listItem, {node: block, serializers, index, key, options}, children)\n  }\n\n  function serializeList(list) {\n    const type = list.listItem\n    const level = list.level\n    const key = list._key\n    const children = list.children.map(serializeNode)\n    return h(serializers.list, {key, level, type, options}, children)\n  }\n\n  // Default to false, so `undefined` will evaluate to the default here\n  const renderContainerOnSingleChild = Boolean(props.renderContainerOnSingleChild)\n\n  const nodes = blocks.map(serializeNode)\n  if (renderContainerOnSingleChild || nodes.length > 1) {\n    const containerProps = props.className ? {className: props.className} : {}\n    return h(serializers.container, containerProps, nodes)\n  }\n\n  if (nodes[0]) {\n    return nodes[0]\n  }\n\n  return typeof serializers.empty === 'function' ? h(serializers.empty) : serializers.empty\n}\n\nfunction isList(block) {\n  return block._type === 'list' && block.listItem\n}\n\nfunction isListItem(block) {\n  return block._type === 'block' && block.listItem\n}\n\nfunction isSpan(block) {\n  return typeof block === 'string' || block.marks || block._type === 'span'\n}\n\nmodule.exports = blocksToNodes\n","const defaultMarks = ['strong', 'em', 'code', 'underline', 'strike-through']\n\nconst buildMarksTree = block => {\n  const {children, markDefs} = block\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n  const rootNode = {_type: 'span', children: []}\n  let nodeStack = [rootNode]\n\n  children.forEach((span, i) => {\n    const marksNeeded = sortedMarks[i]\n    if (!marksNeeded) {\n      const lastNode = nodeStack[nodeStack.length - 1]\n      lastNode.children.push(span)\n      return\n    }\n\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed. (?)\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos].markKey\n        const index = marksNeeded.indexOf(mark)\n        // eslint-disable-next-line max-depth\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = findLastParentNode(nodeStack)\n    marksNeeded.forEach(mark => {\n      const node = {\n        _type: 'span',\n        _key: span._key,\n        children: [],\n        mark: markDefs.find(def => def._key === mark) || mark,\n        markKey: mark\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    })\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(lines)\n    } else {\n      currentNode.children = currentNode.children.concat(span)\n    }\n  })\n\n  return rootNode.children\n}\n\n// We want to sort all the marks of all the spans in the following order:\n// 1. Marks that are shared amongst the most adjacent siblings\n// 2. Non-default marks (links, custom metadata)\n// 3. Built-in, plain marks (bold, emphasis, code etc)\nfunction sortMarksByOccurences(span, i, spans) {\n  if (!span.marks || span.marks.length === 0) {\n    return span.marks || []\n  }\n\n  const markOccurences = span.marks.reduce((occurences, mark) => {\n    occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1\n\n    for (let siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {\n      const sibling = spans[siblingIndex]\n\n      if (sibling.marks && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n\n    return occurences\n  }, {})\n\n  const sortByOccurence = sortMarks.bind(null, markOccurences)\n\n  // Slicing because sort() mutates the input\n  return span.marks.slice().sort(sortByOccurence)\n}\n\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA] || 0\n  const bOccurences = occurences[markB] || 0\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aDefaultPos = defaultMarks.indexOf(markA)\n  const bDefaultPos = defaultMarks.indexOf(markB)\n\n  // Sort default marks last\n  if (aDefaultPos !== bDefaultPos) {\n    return aDefaultPos - bDefaultPos\n  }\n\n  // Sort other marks simply by key\n  if (markA < markB) {\n    return -1\n  } else if (markA > markB) {\n    return 1\n  }\n\n  return 0\n}\n\nfunction isTextSpan(node) {\n  return (\n    node._type === 'span' &&\n    typeof node.text === 'string' &&\n    (Array.isArray(node.marks) || typeof node.marks === 'undefined')\n  )\n}\n\nfunction findLastParentNode(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const node = nodes[i]\n    if (node._type === 'span' && node.children) {\n      return node\n    }\n  }\n\n  return undefined\n}\n\nmodule.exports = buildMarksTree\n","const objectAssign = require('object-assign')\n\n/* eslint-disable max-depth, complexity */\nfunction nestLists(blocks, mode = 'html') {\n  const tree = []\n  let currentList\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!isListBlock(block)) {\n      tree.push(block)\n      currentList = null\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if (block.level > currentList.level) {\n      const newList = listFromBlock(block)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // We actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = lastChild(currentList)\n        const newLastChild = objectAssign({}, lastListItem, {\n          children: lastListItem.children.concat(newList)\n        })\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        currentList.children.push(newList)\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if (block.level < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const match = findListMatching(tree[tree.length - 1], block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const match = findListMatching(tree[tree.length - 1], {level: block.level})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction isListBlock(block) {\n  return Boolean(block.listItem)\n}\n\nfunction blockMatchesList(block, list) {\n  return block.level === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(block) {\n  return {\n    _type: 'list',\n    _key: `${block._key}-parent`,\n    level: block.level,\n    listItem: block.listItem,\n    children: [block]\n  }\n}\n\nfunction lastChild(block) {\n  return block.children && block.children[block.children.length - 1]\n}\n\nfunction findListMatching(rootNode, matching) {\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    rootNode._type === 'list' &&\n    rootNode.level === matching.level &&\n    (filterOnType && rootNode.listItem === matching.listItem)\n  ) {\n    return rootNode\n  }\n\n  const node = lastChild(rootNode)\n  if (!node) {\n    return false\n  }\n\n  return findListMatching(node, matching)\n}\n\nmodule.exports = nestLists\n","const objectAssign = require('object-assign')\n\nmodule.exports = blocks => {\n  return blocks.map(block => {\n    if (block._key) {\n      return block\n    }\n\n    return objectAssign({_key: getStaticKey(block)}, block)\n  })\n}\n\nfunction getStaticKey(item) {\n  return checksum(JSON.stringify(item))\n    .toString(36)\n    .replace(/[^A-Za-z0-9]/g, '')\n}\n\n/* eslint-disable no-bitwise */\nfunction checksum(str) {\n  let hash = 0\n  const strlen = str.length\n  if (strlen === 0) {\n    return hash\n  }\n\n  for (let i = 0; i < strlen; i++) {\n    hash = (hash << 5) - hash + str.charCodeAt(i)\n    hash &= hash // Convert to 32bit integer\n  }\n\n  return hash\n}\n/* eslint-enable no-bitwise */\n","const React = require('react')\nconst {getSerializers} = require('@sanity/block-content-to-hyperscript/internals')\n\nconst renderNode = React.createElement\nconst {defaultSerializers, serializeSpan} = getSerializers(renderNode)\n\nmodule.exports = {\n  serializeSpan,\n  serializers: defaultSerializers,\n  renderProps: {nestMarks: true}\n}\n","import React, {useContext} from 'react'\nimport styled from 'styled-components'\nimport { AboutContext } from '../store/AboutContext'\nimport PortableText from '@sanity/block-content-to-react'\n\nconst Container = styled.div`\n\n    min-height: 100vh;\n    width: 100%;\n    display: flex;\n    justify-content: flex-start;\n    align-items: flex-start;\n    flex-flow: column wrap;\n    text-align: left;\n    padding: 7%;\n    box-sizing: border-box;\n    font-family: 'Helvetica'\n`\n\nconst DescContainer = styled.div`\n    width: 50%;\n    font-size: 36px;\n    font-family: 'Helvetica'\n`\nconst Desc = styled(PortableText)`\n\n`\n\nconst Press = styled.p`\n    font-size: 32px;\n    font-family: 'Helvetica', 'Arial', sans-serif;\n`\n\nconst PressLinkContainer = styled.div`\n    display: flex;\n    justify-content: center;\n    align-items: flex-start;\n    flex-flow: column wrap;\n    text-align: left;\n    width: 100%;\n`\n\nconst PressLink = styled.a`\n    text-decoration: none;\n    color: white;\n    font-weight: 400;\n    font-size: 22px;\n    line-height: 50px;\n    `\n\nconst About = () => {\n    const { about } = useContext(AboutContext)\n    return (\n        <Container >\n            <DescContainer>\n            <Desc blocks={about.about} />\n            <Press>{about.pressMessage}</Press>\n            <PressLinkContainer>\n            {about ? about.press.map((item, id) => <PressLink key={id} href={item.link}>>{item.name}</PressLink>\n            ): null}\n            </PressLinkContainer>\n           \n            </DescContainer>\n            \n        </Container>\n    )\n}\n\nexport default About\n"],"sourceRoot":""}